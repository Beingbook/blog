---
title: 알아두면 쓸데있는 React Hook - useState
description: 컴포넌트 수준 상태관리, 상태변경 갱신 큐와 효율적이고 안전한 일괄처리
createdAt: 2019-04-16
status: published
---

React Hook이 등장한지 1분기가 넘어 갔습니다.
아주 편리하고 매혹적인 기능입니다.
상태 로직을 컴포넌트 라이프사이클에 걸쳐 추상화할 수 있게 되면서
클래스 컴포넌트에 비해 상대적으로 컴포넌트의 멱등성을 만족하기 쉬워졌습니다.

단점이라면 설계자의 의도대로 **React를 모르더라도 쓰기 쉽게 설계되어** 있어서 그냥 지나칠 수 있는 부분들이 있습니다.
React Hook 출시 이후 프로덕션에서 사용하면서 스스로 혹은 동료가 잘 모르던 부분을 정리한 글입니다.

React Hook 도입을 고려하시거나 React를 입문하신다면 도움이 될 것 같습니다.
사실 몇가지는 Hook이 아니더라도 발생하는 문제가 포함되어 있습니다.

## 컴포넌트 상태

React는 컴포넌트 단위로 고립된 상태를 관리할 수 있는 인터페이스를 제공합니다.

```jsx highlight={2}
const StatefulComponent = () => {
  const [state, setState] = React.useState('your input');
  return (
    <>
      <input
        type="text"
        value={state}
        onChange={(event) => setState(event.target.value)}
      />
      <span>{state}</span>
    </>
  );
};
```

위 코드에서 사용된 `React.useState` 함수는 초기 상태값`your input`을 받고
상태(`state`)와 상태를 갱신하는 함수(`setState`)의 쌍을 반환합니다.

`setState`를 실행하면 인자로 전달된 값이 다음 상태가 됩니다.
상태가 갱신되면 컴포넌트는 다시 렌더링됩니다.

`useState`는 내부적으로 React Hook 연결리스트에
[새로운 Hook 노드를 추가](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js#L521)하거나
[기존 Hook 노드를 갱신](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js#L793)하는 역할을 수행합니다.

### 상태 초기화

`useState`로 전달되는 인자는 이후 바뀌더라도 첫 렌더링 외엔 변하지 않습니다.

```jsx highlight={3-4}
const Component = () => {
  // ...
  // 이후 렌더링이 계속 일어나더라도 `state`는 처음 상태로만 유지됩니다.
  const [state, setState] = React.useState(Math.random() * 1000);
  // ...
};
```

컴포넌트가 마운트 된 이후에 갱신을 원한다면 `setState`를 호출하세요.

`useState`의 [인자로 함수를 넘겨서 매 렌더링마다 비싼 연산이 일어나는 것을 방지할 수 있습니다.](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js#L772)

```jsx highlight={4-7}
const expensiveCalc = (n) => (n > 1 ? expensiveCalc(n - 1) + n : n);
const Component = () => {
  // ...
  // 필요없는 비싼 연산이 매 렌더링마다 실행됩니다.
  const [wrong, setWrong] = React.useState(expensiveCalc(100));
  // `expensiveCalc(100)`은 처음 상태 마운트 시점에만 실행됩니다.
  const [state, setState] = React.useState(() => expensiveCalc(100));
  // ...
};
```

모든 상태 초기화를 함수로 할 필요는 없습니다.
성능에 크리티컬한 부분에서만 사용하면 됩니다.

## 일괄 상태 갱신

React가 컴포넌트를 렌더링하는 동안 `setState`를 호출하더라도 상태를 즉시 바꾸진 않습니다.
`setState`를 호출하면 일어나는 일은 다음과 같습니다.

1. [`setState`에 전달된 인자를 액션 큐에 저장합니다.](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js#L1344)
2. [상태변경 큐가 다 쌓였다고 가정하는 시점에 상태를 갱신합니다.](https://overreacted.io/ko/react-as-a-ui-runtime/#%EC%9D%BC%EA%B4%84-%EC%9E%91%EC%97%85)
3. 최종 갱신된 상태로 React가 다시 렌더링합니다.

React는 **불필요한 렌더링을 줄이기 위해서 상태 갱신을 일괄적으로 처리**하기 때문에
`setState`함수는 동기적으로 동작하지 않습니다.

클래스 컴포넌트의 `this.setState`도 갱신 큐를 쌓아놓고 동작합니다.
다만 [`this.setState`는 `react-dom`, `react-native`같은 렌더러들이 주입해주는 갱신 큐를 사용한다는 차이점이 있습니다.](https://github.com/facebook/react/blob/d584fcdc6e10b9f4d4e9eec775731e7ffc0fb501/packages/react/src/ReactBaseClasses.js#L21)

### 상태변경 액션

올바른 상태변화를 보장하기 위해 함수를 전달해야 될 때도 있습니다.
아래 두 컴포넌트는 동작이 다릅니다.

```jsx highlight={5,14}
const WrongComponent = () => {
  // ...
  const [state, setState] = React.useState(100);
  for (let i = 0; i < 5; i += 1) {
    setState(state + 10);
  }
  // ...
};

const CorrectComponent = () => {
  // ...
  const [state, setState] = React.useState(100);
  for (let i = 0; i < 5; i += 1) {
    setState((prevState) => prevState + 10);
  }
  // ...
};
```

import Example1 from './Example1';
import Example2 from './Example2';

<Example1 />

<br />

<Example2 />

<br />

기존 상태를 이용하여 상태를 덧붙이는 작업을 할 때엔 함수를 넘겨 이전 상태를 참조해야 합니다.
위 예제는 다음 코드와 유사하게 동작합니다.

```jsx
// 참고: 실제 React 코드가 아닙니다.
const updateQueue = [110, 110, 110, 110, 110];

const updateQueue2 = [
  (prevState) => prevState + 10,
  (prevState) => prevState + 10,
  (prevState) => prevState + 10,
  (prevState) => prevState + 10,
  (prevState) => prevState + 10,
];

const dispatchActions = (lastState, action) =>
  typeof action === 'function' ? action(lastState) : action;

// 110
const wrongState = updateQueue.reduce(dispatchActions, 100);
// 150
const correctState = updateQueue2.reduce(dispatchActions, 100);
```

[실제 React Action 큐](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js#L1060)는
단순한 배열 대신에 연결리스트를 사용하여 구현되어 있습니다.

## 정리

1. 비싼 연산의 경우 값 대신 함수로 분리하여 매 렌더링마다 발생하는 비용 줄일 수 있습니다.
2. React는 상태변화를 즉각적으로 만들지 않고 큐에 쌓아놓고 일괄적으로 처리합니다.
3. `setState`에 값을 넘기는 대신 함수를 넘겨 일괄처리에서 원자성을 보장할 수 있습니다.
4. React 내부에는 상태관리를 위해 연결리스트를 사용합니다.
