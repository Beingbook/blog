---
title: 알아두면 쓸데있는 React.useState Hook
description: 컴포넌트 수준 상태관리, 상태변경 갱신 큐와 효율적이고 안전한 일괄처리
createdAt: 2019-04-16
status: published
---

다음과 같은 생각을 가지신 분들에게 읽기를 추천드립니다.

1. React.setState 동작이 이상한 것 같아요.
2. React가 어떻게 상태변화를 관리하는지 궁금합니다.

## 컴포넌트 상태

React는 컴포넌트 단위로 고립된 상태를 관리할 수 있는 인터페이스를 제공해줍니다.

```jsx highlight={2}
const StatefulComponent = () => {
  const [state, setState] = React.useState('your input');
  return (
    <>
      <input
        type="text"
        value={state}
        onChange={(event) => setState(event.target.value)}
      />
      <span>{state}</span>
    </>
  );
};
```

위 코드에서 사용된 `React.useState` 함수는 초기 상태값`your input`을 받고
상태(`state`)와 상태를 갱신하는 함수(`setState`)의 쌍을 반환합니다.
(React 코드 내부적으로는 `setState`의 이름을 `dispatch`라고 부릅니다.)

`setState`를 실행하면 인자로 전달된 값이 다음 상태가 됩니다.
상태가 갱신되면 컴포넌트는 다시 렌더링됩니다.

### 상태 초기화

`useState`로 전달되는 인자는 이후 바뀌더라도 첫 렌더링 외엔 변하지 않습니다.

```jsx highlight={3-4}
const Component = () => {
  // ...
  // 이후 렌더링이 계속 일어나더라도 `state`는 처음 상태로만 유지됩니다.
  const [state, setState] = React.useState(Math.random() * 1000);
  // ...
};
```

`useState`의 [인자로 함수를 넘겨서 매 렌더링마다 비싼 연산이 일어나는 것을 방지할 수 있습니다.](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js#L772)

```jsx highlight={4-7}
const expensiveCalc = (n) => (n > 1 ? expensiveCalc(n - 1) + n : n);
const Component = () => {
  // ...
  // 필요없는 비싼 연산이 매 렌더링마다 실행됩니다.
  const [wrong, setWrong] = React.useState(expensiveCalc(100));
  // `expensiveCalc(100)`은 처음 한 번만 실행됩니다.
  const [state, setState] = React.useState(() => expensiveCalc(100));
  // ...
};
```

## 일괄 상태 갱신

React가 컴포넌트를 렌더링하는 동안 `setState`를 호출하더라도 상태를 즉시 바꾸진 않습니다.
`setState`를 호출하면 일어나는 일은 다음과 같습니다.

1. [`setState`에 전달된 인자를 액션 큐에 저장합니다.](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js#L1344)
2. [상태변경 큐가 다 쌓였다고 가정하는 시점에 상태를 갱신합니다.](https://overreacted.io/ko/react-as-a-ui-runtime/#%EC%9D%BC%EA%B4%84-%EC%9E%91%EC%97%85)
3. 최종 갱신된 상태로 React가 다시 렌더링합니다.

React는 **불필요한 렌더링을 줄이기 위해서 상태 갱신을 일괄적으로 처리**하기 때문에
`setState`함수는 동기적으로 동작하지 않습니다.

### 상태변경 액션

올바른 상태변화를 보장하기 위해 함수를 전달해야 될 때도 있습니다.
아래 두 컴포넌트는 동작이 다릅니다.

```jsx highlight={5,14}
const WrongComponent = () => {
  // ...
  const [state, setState] = React.useState(100);
  for (let i = 0; i < 5; i += 1) {
    setState(state + 10);
  }
  // ...
};

const CorrectComponent = () => {
  // ...
  const [state, setState] = React.useState(100);
  for (let i = 0; i < 5; i += 1) {
    setState((prevState) => prevState + 10);
  }
  // ...
};
```

import Example1 from './Example1';
import Example2 from './Example2';

<Example1 />

<br />

<Example2 />

<br />

기존 상태를 이용하여 상태를 덧붙이는 작업을 할 때엔 함수를 넘겨 이전 상태를 참조해야 합니다.
위 예제는 다음 코드와 유사하게 동작합니다.

```jsx
// 참고: 실제 React 코드가 아닙니다.
const updateQueue = [110, 110, 110, 110, 110];

const updateQueue2 = [
  (prevState) => prevState + 10,
  (prevState) => prevState + 10,
  (prevState) => prevState + 10,
  (prevState) => prevState + 10,
  (prevState) => prevState + 10,
];

const dispatchActions = (lastState, action) =>
  typeof action === 'function' ? action(lastState) : action;

// 110
const wrongState = updateQueue.reduce(dispatchActions, 100);
// 150
const correctState = updateQueue2.reduce(dispatchActions, 100);
```

[실제 React Action 큐](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js#L1060)는
단순한 배열 대신에 연결리스트를 사용하여 구현되어 있습니다.

## 정리

1. 비싼 연산의 경우 별도의 함수로 분리하여 비용을 줄일 수 있습니다.
2. React는 상태변화를 즉각적으로 만들지 않고 큐에 쌓아놓고 일괄적으로 처리합니다.
3. `setState`에 값을 넘기는 대신 함수를 넘겨 일괄처리에서 원자성을 보장할 수 있습니다.
